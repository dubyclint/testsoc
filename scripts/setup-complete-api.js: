// scripts/setup-complete-api.js
import { writeFileSync, mkdirSync, existsSync, readdirSync, statSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, '..');

// Utility functions
const ensureDir = (dir) => {
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
    console.log(`ðŸ“ Created directory: ${dir}`);
  }
};

const writeFile = (filePath, content) => {
  ensureDir(dirname(filePath));
  writeFileSync(filePath, content);
  console.log(`âœ… Created: ${filePath}`);
};

const findFiles = (dir, extension = '.js') => {
  if (!existsSync(dir)) return [];
  
  const files = [];
  const items = readdirSync(dir);
  
  items.forEach(item => {
    const fullPath = join(dir, item);
    const stat = statSync(fullPath);
    
    if (stat.isDirectory()) {
      files.push(...findFiles(fullPath, extension));
    } else if (item.endsWith(extension)) {
      files.push(fullPath);
    }
  });
  
  return files;
};

// Controller templates
const controllerTemplates = {
  pewController: `// controllers/pewController.js
import { supabase } from '~/utils/supabase.js';

export class PewController {
  static async createPew(req, res) {
    try {
      const { sender_id, receiver_id, pew_type, content, media_url, location } = req.body;
      
      const { data: pew, error } = await supabase
        .from('pews')
        .insert({
          sender_id,
          receiver_id,
          pew_type: pew_type || 'text',
          content,
          media_url,
          location,
          status: 'sent',
          created_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) throw error;

      return res.status(201).json({
        success: true,
        message: 'Pew sent successfully',
        data: pew
      });
    } catch (error) {
      console.error('Error creating pew:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async getUserPews(req, res) {
    try {
      const { userId } = req.params;
      const { page = 1, limit = 20 } = req.query;
      const offset = (page - 1) * limit;

      const { data: pews, error } = await supabase
        .from('pews')
        .select(\`
          *,
          sender:users!pews_sender_id_fkey(id, username, avatar_url),
          receiver:users!pews_receiver_id_fkey(id, username, avatar_url)
        \`)
        .or(\`sender_id.eq.\${userId},receiver_id.eq.\${userId}\`)
        .order('created_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) throw error;

      return res.status(200).json({
        success: true,
        data: pews
      });
    } catch (error) {
      console.error('Error fetching user pews:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async markAsRead(req, res) {
    try {
      const { pewId } = req.params;
      const { user_id } = req.body;

      const { data: pew, error } = await supabase
        .from('pews')
        .update({ 
          status: 'read',
          read_at: new Date().toISOString()
        })
        .eq('id', pewId)
        .eq('receiver_id', user_id)
        .select()
        .single();

      if (error) throw error;

      return res.status(200).json({
        success: true,
        message: 'Pew marked as read',
        data: pew
      });
    } catch (error) {
      console.error('Error marking pew as read:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async deletePew(req, res) {
    try {
      const { pewId } = req.params;
      const { user_id } = req.body;

      const { data: pew, error: fetchError } = await supabase
        .from('pews')
        .select('sender_id')
        .eq('id', pewId)
        .single();

      if (fetchError) throw fetchError;

      if (pew.sender_id !== user_id) {
        return res.status(403).json({ error: 'Unauthorized to delete this pew' });
      }

      const { error } = await supabase
        .from('pews')
        .delete()
        .eq('id', pewId);

      if (error) throw error;

      return res.status(200).json({
        success: true,
        message: 'Pew deleted successfully'
      });
    } catch (error) {
      console.error('Error deleting pew:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async getConversation(req, res) {
    try {
      const { userId, partnerId } = req.params;
      const { page = 1, limit = 50 } = req.query;
      const offset = (page - 1) * limit;

      const { data: pews, error } = await supabase
        .from('pews')
        .select(\`
          *,
          sender:users!pews_sender_id_fkey(id, username, avatar_url)
        \`)
        .or(\`and(sender_id.eq.\${userId},receiver_id.eq.\${partnerId}),and(sender_id.eq.\${partnerId},receiver_id.eq.\${userId})\`)
        .order('created_at', { ascending: true })
        .range(offset, offset + limit - 1);

      if (error) throw error;

      return res.status(200).json({
        success: true,
        data: pews
      });
    } catch (error) {
      console.error('Error fetching conversation:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  }
}`,

  walletController: `// controllers/walletController.js
import { supabase } from '~/utils/supabase.js';

export class WalletController {
  static async createUserWallets(req, res) {
    try {
      const { userId } = req.body;
      
      if (!userId) {
        return res.status(400).json({ error: 'User ID is required' });
      }

      const currencies = [
        { code: 'USDT', name: 'Tether' },
        { code: 'USDC', name: 'USD Coin' },
        { code: 'BTC', name: 'Bitcoin' },
        { code: 'ETH', name: 'Ethereum' },
        { code: 'SOL', name: 'Solana' },
        { code: 'MATIC', name: 'Polygon' },
        { code: 'XAUT', name: 'Tether Gold' }
      ];

      const walletInserts = currencies.map(currency => ({
        user_id: userId,
        currency_code: currency.code,
        currency_name: currency.name,
        balance: 0.00,
        locked_balance: 0.00,
        wallet_address: \`\${currency.code.toLowerCase()}_\${userId}\`,
        wallet_type: 'internal'
      }));

      const { data: wallets, error } = await supabase
        .from('wallets')
        .insert(walletInserts)
        .select();

      if (error) throw error;
      
      return res.status(201).json({
        success: true,
        message: 'User wallets created successfully',
        data: wallets
      });
    } catch (error) {
      console.error('Error creating user wallets:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async getUserWallets(req, res) {
    try {
      const { userId } = req.params;
      
      const { data: wallets, error } = await supabase
        .from('wallets')
        .select('*')
        .eq('user_id', userId);

      if (error) throw error;

      return res.status(200).json({
        success: true,
        data: wallets
      });
    } catch (error) {
      console.error('Error fetching user wallets:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async updateBalance(req, res) {
    try {
      const { walletId } = req.params;
      const { amount, type, description } = req.body;
      
      if (!amount || !type) {
        return res.status(400).json({ error: 'Amount and type are required' });
      }

      const { data: wallet, error: fetchError } = await supabase
        .from('wallets')
        .select('balance')
        .eq('id', walletId)
        .single();

      if (fetchError) throw fetchError;

      const newBalance = type === 'credit' 
        ? parseFloat(wallet.balance) + parseFloat(amount)
        : parseFloat(wallet.balance) - parseFloat(amount);

      if (newBalance < 0) {
        return res.status(400).json({ error: 'Insufficient balance' });
      }

      const { data: updatedWallet, error: updateError } = await supabase
        .from('wallets')
        .update({ 
          balance: newBalance,
          updated_at: new Date().toISOString()
        })
        .eq('id', walletId)
        .select()
        .single();

      if (updateError) throw updateError;

      return res.status(200).json({
        success: true,
        message: 'Wallet balance updated successfully',
        data: updatedWallet
      });
    } catch (error) {
      console.error('Error updating wallet balance:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async lockBalance(req, res) {
    try {
      const { walletId } = req.params;
      const { amount, action } = req.body;
      
      const { data: wallet, error: fetchError } = await supabase
        .from('wallets')
        .select('balance, locked_balance')
        .eq('id', walletId)
        .single();

      if (fetchError) throw fetchError;

      let newBalance, newLockedBalance;

      if (action === 'lock') {
        if (parseFloat(wallet.balance) < parseFloat(amount)) {
          return res.status(400).json({ error: 'Insufficient balance to lock' });
        }
        newBalance = parseFloat(wallet.balance) - parseFloat(amount);
        newLockedBalance = parseFloat(wallet.locked_balance) + parseFloat(amount);
      } else {
        newBalance = parseFloat(wallet.balance) + parseFloat(amount);
        newLockedBalance = parseFloat(wallet.locked_balance) - parseFloat(amount);
      }

      const { data: updatedWallet, error: updateError } = await supabase
        .from('wallets')
        .update({ 
          balance: newBalance,
          locked_balance: newLockedBalance,
          updated_at: new Date().toISOString()
        })
        .eq('id', walletId)
        .select()
        .single();

      if (updateError) throw updateError;

      return res.status(200).json({
        success: true,
        message: \`Balance \${action}ed successfully\`,
        data: updatedWallet
      });
    } catch (error) {
      console.error('Error locking/unlocking balance:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async getWalletByCurrency(req, res) {
    try {
      const { userId, currencyCode } = req.params;
      
      const { data: wallet, error } = await supabase
        .from('wallets')
        .select('*')
        .eq('user_id', userId)
        .eq('currency_code', currencyCode)
        .single();

      if (error) throw error;

      return res.status(200).json({
        success: true,
        data: wallet
      });
    } catch (error) {
      console.error('Error fetching wallet by currency:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async getTransactionHistory(req, res) {
    try {
      const { walletId } = req.params;
      const { page = 1, limit = 20 } = req.query;
      const offset = (page - 1) * limit;

      const { data: transactions, error } = await supabase
        .from('wallet_transactions')
        .select('*')
        .eq('wallet_id', walletId)
        .order('created_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) throw error;

      return res.status(200).json({
        success: true,
        data: transactions
      });
    } catch (error) {
      console.error('Error fetching transaction history:', error);
      return res.status(500).json({ error: 'Internal server error' });
    }
  }
}`,

  // Add abbreviated versions of other controllers to save space...
  tradeController: `// controllers/tradeController.js
import { supabase } from '~/utils/supabase.js';

export class TradeController {
  static async createTrade(req, res) {
    // Implementation here...
    return res.status(201).json({ success: true, message: 'Trade created' });
  }
  
  static async getActiveTrades(req, res) {
    // Implementation here...
    return res.status(200).json({ success: true, data: [] });
  }
  
  static async getUserTrades(req, res) {
    // Implementation here...
    return res.status(200).json({ success: true, data: [] });
  }
  
  static async updateTradeStatus(req, res) {
    // Implementation here...
    return res.status(200).json({ success: true, message: 'Trade updated' });
  }
  
  static async acceptTrade(req, res) {
    // Implementation here...
    return res.status(200).json({ success: true, message: 'Trade accepted' });
  }
  
  static async getTradeById(req, res) {
    // Implementation here...
    return res.status(200).json({ success: true, data: {} });
  }
  
  static async deleteTrade(req, res) {
    // Implementation here...
    return res.status(200).json({ success: true, message: 'Trade deleted' });
  }
}`
};

// Route template generator
const createRouteTemplate = (controllerName, methodName, params = [], hasBody = false, hasQuery = false) => {
  const paramNames = params.map(p => p.replace('[', '').replace(']', ''));
  const paramGetters = paramNames.map(p => `  const ${p} = getRouterParam(event, '${p}');`).join('\n');
  
  const reqObject = {
    params: paramNames.length > 0 ? `{ ${paramNames.join(', ')} }` : undefined,
    body: hasBody ? 'body' : undefined,
    query: hasQuery ? 'query' : undefined
  };
  
  const reqParts = Object.entries(reqObject)
    .filter(([_, value]) => value !== undefined)
    .map(([key, value]) => `${key}: ${value}`)
    .join(', ');

  const depth = params.length + 2;
  const relativePath = '../'.repeat(depth);

  return `import { ${controllerName} } from '${relativePath}controllers/${controllerName.toLowerCase()}.js';

export default defineEventHandler(async (event) => {
${paramGetters}
  ${hasBody ? 'const body = await readBody(event);' : ''}
  ${hasQuery ? 'const query = getQuery(event);' : ''}
  
  const req = { ${reqParts} };
  const res = {
    status: (code) => ({ json: (data) => ({ statusCode: code, ...data }) }),
    json: (data) => data
  };

  try {
    return await ${controllerName}.${methodName}(req, res);
  } catch (error) {
    throw createError({
      statusCode: 500,
      statusMessage: error.message
    });
  }
});`;
};

// Route definitions
const routes = [
  // Pew routes
  ['server/api/pews/index.post.js', 'PewController', 'createPew', [], true],
  ['server/api/pews/user/[userId].get.js', 'PewController', 'getUserPews', ['userId'], false, true],
  ['server/api/pews/[pewId]/read.patch.js', 'PewController', 'markAsRead', ['pewId'], true],
  ['server/api/pews/[pewId].delete.js', 'PewController', 'deletePew', ['pewId'], true],
  ['server/api/pews/conversation/[userId]/[partnerId].get.js', 'PewController', 'getConversation', ['userId', 'partnerId'], false, true],

  // Wallet routes
  ['server/api/wallets/create.post.js', 'WalletController', 'createUserWallets', [], true],
  ['server/api/wallets/user/[userId].get.js', 'WalletController', 'getUserWallets', ['userId']],
  ['server/api/wallets/[walletId]/balance.patch.js', 'WalletController', 'updateBalance', ['walletId'], true],
  ['server/api/wallets/[walletId]/lock.patch.js', 'WalletController', 'lockBalance', ['walletId'], true],
  ['server/api/wallets/[userId]/[currencyCode].get.js', 'WalletController', 'getWalletByCurrency', ['userId', 'currencyCode']],
  ['server/api/wallets/[walletId]/transactions.get.js', 'WalletController', 'getTransactionHistory', ['walletId'], false, true],

  // Trade routes
  ['server/api/trades/index.post.js', 'TradeController', 'createTrade', [], true],
  ['server/api/trades/active.get.js', 'TradeController', 'getActiveTrades', [], false, true],
  ['server/api/trades/user/[userId].get.js', 'TradeController', 'getUserTrades', ['userId'], false, true],
  ['server/api/trades/[tradeId]/status.patch.js', 'TradeController', 'updateTradeStatus', ['tradeId'], true],
  ['server/api/trades/[tradeId]/accept.patch.js', 'TradeController', 'acceptTrade', ['tradeId'], true],
  ['server/api/trades/[tradeId].get.js', 'TradeController', 'getTradeById', ['tradeId']],
  ['server/api/trades/[tradeId].delete.js', 'TradeController', 'deleteTrade', ['tradeId'], true],

  // Add more routes as needed...
];

// Main setup function
async function setupCompleteAPI() {
  console.log('ðŸš€ Setting up complete API structure...\n');
  
  // Step 1: Create utils/supabase.js if it doesn't exist
  const supabaseUtilPath = join(projectRoot, 'utils/supabase.js');
  if (!existsSync(supabaseUtilPath)) {
    const supabaseContent = `// utils/supabase.js
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.SUPABASE_URL
const supabaseAnonKey = process.env.SUPABASE_ANON_KEY

export const supabase = createClient(supabaseUrl, supabaseAnonKey)`;
    
    writeFile(supabaseUtilPath, supabaseContent);
  }

  // Step 2: Create controllers
  console.log('\nðŸ“ Creating controllers...');
  Object.entries(controllerTemplates).forEach(([name, content]) => {
    const filePath = join(projectRoot, 'server/api/controllers', `${name}.js`);
    writeFile(filePath, content);
  });

  // Step 3: Create routes
  console.log('\nðŸ”— Creating API routes...');
  routes.forEach(([filePath, controllerName, methodName, params, hasBody, hasQuery]) => {
    const fullPath = join(projectRoot, filePath);
    const content = createRouteTemplate(controllerName, methodName, params, hasBody, hasQuery);
    writeFile(fullPath, content);
  });

  console.log('\nâœ… API setup complete!');
  console.log('\nNext steps:');
  console.log('1. Add your environment variables to .env');
  console.log('2. Install dependencies: npm install @supabase/supabase-js');
  console.log('3. Test your API endpoints');
  console.log('4. Add authentication middleware where needed');
}

// Run the setup
setupCompleteAPI().catch(console.error);
